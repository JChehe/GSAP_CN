## TweenLite

是一款超级快速、轻量且灵活的工具。它是 GreenSock 动画平台（GSAP）的基础。一个 TweenLite 实例能一次性处理任意对象（或对象数组）的一个或多个属性。虽然 TweenLite 体积小，但能独立完成大多数小型动画。它也可以结合 TimelineLite 或 TimelineMax 等高级队列工具去轻易地完成复杂任务。在有其他几个动画框架可供选择的情况下，为何要考虑 GSAP 呢？

* 速度：本平台经过高度优化，力求达到最佳性能。查看一些速度比较：[http://greensock.com/js/speed.html](http://greensock.com/js/speed.html)
* 异常强大的特性集：为了能过渡对象的所有数字型属性，TweenLite 拥有能过渡十六进制颜色值、贝塞尔曲线、CSS、SVG、变形（morphing）等一系列插件。还能对值进行四舍五入、使用相对值、随意使用 \`reverse\(\)\`、自动检测和适应 getter/setter 函数、能使用几乎所有缓动函数、随时 pause\(\)/resume\(\)、通过各种覆盖模式，智能管理相同对象的冲突补间。TweenMax 在 TweenLite 的基础上进行了扩展，添加了更多能力，如 repeat、yoyo、repeatDelay 等。
* 队列、编组和管理特性：TimelineLite 和 TimelineMax 让创建复杂的补间队列或组合变得超级简单。即将多个补间作为一个整体进行`play()`、`pause()`、`restart()`或 `reverse()`等操作。通过时间轴的 time\(\) 或 progress\(\) 方法进行快进或回退，也可以添加标记、更改时间轴的播放速度 timeScale\(\)、时间轴内嵌套时间轴等等。这无疑能对你的动画工作流进行革新，使其更模块化和简洁。
* 易于使用：设计师和开发者都对本平台的直观性点赞。
* 支持与可靠性：频繁迭代、专用论坛、忠诚的作者、可靠的跟踪记录、成熟的资助机制和旺盛的社区用户，保证了平台的安全性和长期性（不像很多开源项目）。
* 可扩展性：基于其插件架构，可以根据项目需要启用相应的额外特性。而自定义开发的插件，因其仅处理特定的特殊属性，能最大限度减少体积和发挥最大性能。

### 用法

阅读[《Jump Start tour》](https://greensock.com/jump-start-js)可以快速入门，它以有趣和可交互的方式展示了平台的基础部分。

补间动画最常用的方式是 TweenLite.to\(\)，它允许你定义目标值：

```js
var photo = document.getElementById("photo");
TweenLite.to(photo, 2, { width: "200px", height: "150px" });
```

上述代码将对 id 为 "photo" 的 &lt;img&gt; 元素的宽高在 2 秒内分别从当前值过渡到 200 和 150。需要注意的是：width 和 height 的值均定义在一个对象字面量（大括号内）中。你可以在里面定义任意多个属性。为了对 CSS 属性做补间动画，你需要使用 CSSPlugin。CSSPlugin 包含了解析和以独特方式处理 CSS 相关属性的特定代码，如识别颜色、transform 等，并且需要管理必要的后缀（"px"、"%" 等）。

若向补间对象传递一个字符串（文本），如 `TweenLite.to("#myID", 1, { left: "100px" })`，TweenLite 则会使用选择器引擎（优先使用 jQuery、然后使用 `document.querySelectorAll()` 最后使用 `document.getElementById()`（自动移除 "\#" 前缀））。

所以，一旦 TweenLite 和 CSSPlugin 加载完毕后，即可像下面一样轻松创建补间动画：

```js
//tween the element with ID of "myID"
TweenLite.to("#myID", 2, {backgroundColor:"#ff0000", width:"50%", top:"100px", ease:Power2.easeInOut});

//tween every element with the class "myClass" like this: 
TweenLite.to(".myClass", 2, {boxShadow:"0px 0px 20px red", color:"#FC0"});
```

对应 Codepen：[Animate Multiple Properties](https://codepen.io/GreenSock/pen/wsxjv)

默认情况下，补间动画会立即启动，尽管你可以通过 `delay` 属性对其进行延迟启动，或通过 `paused` 属性使其初始暂停。

`target`目标对象可以是一个数组对象。例如，下面的补间动画将会对 obj1、obj2、obj3 的 `opacity` CSS 属性过渡到 0.5，transform 属性旋转到 45 度：

```js
TweenLite.to([obj1, obj2, obj3], 1, {opacity:0.5, rotation:45});
```

一般情况下，CSS 相关属性需要放在特定对象下：`TweenLite.to(element, 1, {css:{left:"100px", top:"50px"}});`，这样引擎才能知道这些属性是属于 CSSPlugin 处理的。但因为在浏览器上对 DOM 元素进行补间动画非常普遍，所以 TweenLite 会自动检测目标元素是否是 DOM 元素，若是（且未在 vars 对象内定义 "css" 对象），TweenLite 则会在补间动画渲染前创建 css 对象，将未直接定义在 css 对象上的属性填充到 css 对象，保留其余类似 `onComplete、ease、delay` 或插件等非 css 相关的属性。

TweenLite.from\(\) 则让你定义初始值而非目标值，即从定义的值过渡到当前值。或使用 TweenLite.fromTo\(\) 定义初始值和目标值。

to\(\)、from\(\)、fromTo\(\) 静态方法很常用，因为它们快捷和避免了一些垃圾回收的麻烦。当然，你也可以使用面向对象的语法，如下：

```js
var tween = new TweenLite(element, 2, {width: 200, height: 150})
```

甚至：

```js
var tween = TweenLite.to(element, 2, {width: 200, height: 150})
```

### 特殊属性、缓动和回调函数（无需引入插件）：

一般来说，`vars`参数是用于定义目标对象的补间属性的目标值（或 from\(\) 补间动画的初始值）如：`{left: "100px", top: "200px", opacity: 0}`，但下面可选的特殊属性则用于其他目的：

* delay（Number）：动画开始前需要延迟的秒数（或帧数，基于帧的补间动画）。

* ease（Ease 或函数或字符串）：不同的缓动函数控制着动画不同的变化速率，赋予不同的“感觉”。如：Elastic.easeOut 或 Strong.easeInOut。为了取得最佳性能，请使用 GreenSock 提供的缓动函数（`Linear、Power0、power1、power2、power3、power4、Quad、Cubic、Quart、Quint` 和 `Strong` 各自的 `.easeIn、.easeOut、.easeInOut` 均包含在 TweenLite，可以通过加载 EasePack 获取额外的缓动函数，如 `Elastic、Back、Bounce、SlowMo、SteppedEase、Circ、Expo` 和 `Sina`）。GreenSock 的 `Linear.easeNone` 则为线性动画。自定义缓动函数的命名风格可以是 "Strong.easeOut" 或“easeOutStrong”（类似 jQuery 的反向风格）。该属性的默认值 `Quad.easeOut`。

* paused（Boolean）：为 `true`  时，动画会在创建后立即停止。

* immediateRender（Boolean）：一般情况下，创建后的补间动画会在最近的下一帧（更新循环）中进行渲染，除非指定了 `delay`。然而，如果想要强制补间动画在创建后立即进行渲染，可将 `immediateRender` 设为 `true`。或者想阻止 `from()` 的立即渲染，可将 `immediateRender` 设为 `false`。默认情况下，`from()` 补间动画的 `immediateRender` 属性为 `true`。

* overwrite（String 或正整数）：该属性用于存在多个目标元素相同的补间动画时，如何控制互相被覆盖的情况。供几个模式可选择，默认值为 `"auto"`：可通过 `TweenLite.defaultOverwrite` 属性更改默认模式：

  * `"none"`（0 或 `false`）：没有覆盖会发生。

  * `"all"`（1 或 `true`）：所有拥有相同目标元素的补间动画均会被立即覆盖，无论补间动画是否开启或是否拥有冲突的属性。

  * `"auto"`（2）：当补间动画首次渲染时，会分析其余拥有相同目标元素的补间动画：它们目前是否为活跃/运行状态？若是，则会单独覆盖冲突的过渡属性。未开始的补间动画则会被暂时忽略。例如：当前存在一个活跃的补间动画（过渡着 3 个属性），而新的一个补间动画与其存在着一个相同的过渡属性。那么在这种情况下，其余两个属性会得到保留，而仅会覆盖那个冲突的属性。这是默认模式，且对于开发者来说，这通常是最直观的模式。

  * `"concurrent"`（3）：当补间动画首次渲染时，会去掉拥有相同目标元素，且为当前活跃状态（正在处理）的补间动画，无论它们是否存在冲突的属性。像是 `"all"` 和 `"auto"` 的结合体。适用于当前仅需一个补间动画控制目标元素的情景。

  * `"allOnStart"`（4）：与 "all" 相同，但会等到补间动画开启时（即在延迟后）才执行覆盖逻辑。所有拥有相同目标元素的补间动画均会被立即覆盖，无论补间动画是否开启或是否拥有冲突的属性。

  * "`preexisting"`（5）：当一个补间动画首次渲染时，它会终止所有在其之前创建的补间动画（拥有相同目标元素），而不管它们所各自设定的启动时间。例如：分别创建一个延时时间为 10、一个延时时间为 1 和一个延时时间为 2 的三个补间动画（拥有相同的目标元素），那么第二个补间动画会终止第一个补间动画，而不会终止第三个（译者注：原文 "the 2nd tween would overwrite the first but not the second"）。`"preexisting"` 只关心实例的实际创建顺序。当代码执行顺序起关键作用时，这会非常有用。

* onComplete（Function）：动画完成时的回调函数。

* onCompleteParams（Array）：传入 `onComplete` 函数的参数数组。例如：`TweenLite.to(element, 1, { left: "100px", onComplete: myFunction, onCompleteParams: [element, "param2"] });`若需要在参数列表中引用补间动画实例自身，可使用`"{self}"`，如：`onCompleteParams:["{self}", "param2"]`

* onCompleteScope（Object）：指定 onComplete 函数的作用域（即函数内 `"this"` 的引用）。

* onReverseComplete（Function）：动画反向运动到初始开始位时所触发的回调函数。例如，当 `reverse()` 被调用时，补间动画将反向运动到初始位置，当其 time 为 0 时，onReverseComplete 函数会被触发。即使将补间动画实例放置在 TimelineLite 或 TimelineMax 实例中，若 Timeline 实例反向运动且到达初始位置时（译者注：补间动画实例的初始位置）也会触发该函数（译者注：补间动画实例的 onReverseComplete 函数）。

* onReverseCompleteParams（Array）：

* onReverseCompleteScope（Object）：

* onStart（Function）:

* onStartParams（Array）：

* onStartScope（Object）：

* onUpdate（Function）：

* onUpdateParams（Array）：

* onUpdateScope（Object）：

* useFrames（Boolean）：

* lazy（Boolean）：

* onOverwrite（Function）：

* autoCSS（Boolean）：

* callbackScope（Object）：



### 插件：



### 基于函数的值





### 案例



### GreenSock 官方教程（视频和电子书）



### 注意事项/提示：







